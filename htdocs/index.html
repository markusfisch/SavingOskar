<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-    scale=1, user-scalable=0"/>
<title>ld43</title>
<style>
html, body {
	margin: 0; padding: 0;
	background: #111; color: #fff;
	font: 3vmin sans-serif;
	-webkit-tap-highlight-color: rgba(0,0,0,0);
	-webkit-touch-callout: none;
	-webkit-user-select: none;
	-khtml-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	-ms-touch-action: none;
	user-select: none;
}

canvas {
	position: fixed;
	width: 100%;
	height: 100%;
}
</style>
</head>
<body>
<canvas id="Canvas">Sorry, this browser cannot render this content.</canvas>
<script id="VertexShader" type="x-shader/x-vertex">
attribute vec2 p;
attribute vec2 uv;

uniform mat3 perspective;
uniform mat3 transformation;

varying vec2 vuv;

void main() {
	gl_Position = vec4(perspective * transformation *
		vec3(p, 1.), 1.);
	vuv = uv;
}
</script>
<script id="FragmentShader" type="x-shader/x-fragment">
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif

varying vec2 vuv;

uniform sampler2D texture;

void main() {
	gl_FragColor = texture2D(texture, vuv.st).rgba;
}
</script>
<script>
'use strict'

var M = Math,
	D = document,
	W = window,
	FA = Float32Array,
	SAND = 1,
	PLAYER = 3,
	DUST = 5,
	atlas,
	canvas,
	sprites = [],
	gl,
	vertexBuffer,
	vertexBufferLoc,
	uvBuffer,
	uvBufferLoc,
	perspective,
	perspectiveLoc,
	transformation,
	transformationLoc,
	texture,
	textureLoc,
	program,
	halfWidth,
	halfHeight,
	yMax,
	scaleFactor,
	spriteSize,
	mapCellSize,
	maxColsInView,
	maxRowsInView,
	map = [],
	mapCols,
	mapRows,
	items = [],
	viewDestX,
	viewDestY,
	viewX,
	viewY,
	viewXMin,
	viewXMax,
	viewYMin,
	viewYMax,
	viewMoveXAt,
	viewMoveYAt,
	now,
	moveUntil = 0,
	moveDuration = 300,
	dust = [],
	dustLength = 20,
	dustDuration = 500,
	pointersLength,
	pointersX = [],
	pointersY = [],
	keysDown = [],
	playerDestX,
	playerDestY,
	playerX,
	playerY,
	gameOver = 0

function drawSprite(sprite, x, y, xm, ym) {
	gl.vertexAttribPointer(uvBufferLoc, 2, gl.FLOAT, gl.FALSE, 0,
		sprite << 5)

	transformation[0] = spriteSize * (xm || 1)
	transformation[4] = spriteSize * (ym || 1)

	transformation[6] = x
	transformation[7] = y

	gl.uniformMatrix3fv(transformationLoc, gl.FALSE, transformation)
	gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
}

function drawMap() {
	var vx = M.min(M.max(viewX, viewXMax), viewXMin),
		vy = M.min(M.max(viewY, viewYMin), viewYMax),
		cl = M.round(M.max(0, -1 - vx) / mapCellSize),
		cr = M.min(cl + maxColsInView, mapCols),
		rt = M.round(M.max(0, vy - yMax) / mapCellSize),
		rb = M.min(rt + maxRowsInView, mapRows),
		offset = rt * mapCols + cl,
		skip = mapCols - (cr - cl),
		l = vx + cl * mapCellSize,
		t = vy - rt * mapCellSize,
		dustSprite = sprites[DUST]
	for (var y = t, r = rt; r < rb; y -= mapCellSize, ++r, offset += skip) {
		// draw row
		for (var x = l, c = cl; c < cr; x += mapCellSize, ++c, ++offset) {
			var floor = sprites[map[offset]]
			drawSprite(floor, x, y)
			var item = items[offset]
			if (item) {
				// draw item
			}
		}
		// draw dust
		for (var i = 0; i < dustLength; ++i) {
			var d = dust[i],
				dx = d.x,
				dy = d.y,
				life = d.life
			if (life > now && dy >= rt && dy < rb &&
					dx >= cl && dx < cr &&
					(dy - r) | 0 == 0) {
				drawSprite(
					dustSprite,
					vx + dx * mapCellSize,
					vy - dy * mapCellSize,
					1,
					1 + (life - now) / dustDuration
				)
			}
		}
		// draw player
		if (!gameOver && playerY >= rt && playerY < rb &&
				playerX >= cl && playerX < cr &&
				(playerY - r) | 0 == 0) {
			drawSprite(
				sprites[PLAYER],
				vx + playerX * mapCellSize,
				vy - playerY * mapCellSize,
				1,
				1 + M.min(.25, M.max(
					M.abs(playerDestX - playerX),
					M.abs(playerDestY - playerY)) * .25)
			)
		}
	}
}

function initFrame() {
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
	gl.useProgram(program)

	gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)
	gl.vertexAttribPointer(vertexBufferLoc, 2, gl.FLOAT, gl.FALSE, 0, 0)
	gl.uniformMatrix3fv(perspectiveLoc, gl.FALSE, perspective)

	gl.activeTexture(gl.TEXTURE0)
	gl.bindTexture(gl.TEXTURE_2D, texture)
	gl.uniform1i(textureLoc, 0)

	gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer)
}

function setViewDest(x, y) {
	viewDestX = -x * mapCellSize
	viewDestY = y * mapCellSize
}

function spawnDust(x, y) {
	var specks = 4 + M.random() * 4 | 0
	for (var i = 0; i < dustLength; ++i) {
		var d = dust[i]
		if (d.life < now) {
			d.x = x + (M.random() - .5) * mapCellSize * 3
			d.y = y + (M.random() - .5) * mapCellSize * 3
			d.life = now + M.random() * dustDuration
			if (--specks < 0) {
				break
			}
		}
	}
}

function run() {
	requestAnimationFrame(run)
	now = Date.now()

	if (moveUntil > now) {
		var p = 1 - ((moveUntil - now) / moveDuration)
		playerX += (playerDestX - playerX) * p
		playerY += (playerDestY - playerY) * p
		viewX += (viewDestX - viewX) * p
		viewY += (viewDestY - viewY) * p
	}

	initFrame()
	drawMap()
}

function canMoveTo(x, y) {
	var offset = y * mapCols + x
	return map[offset] === SAND && items[offset] !== 0
}

function move(dx, dy) {
	var x = M.min(mapCols - 1, M.max(0, playerDestX + dx)),
		y = M.min(mapRows - 1, M.max(0, playerDestY + dy))
	if (canMoveTo(x, y)) {
		playerDestX = x
		playerDestY = y
		if (M.abs(viewDestX + x * mapCellSize) > viewMoveXAt) {
			viewDestX -= mapCellSize * dx
		}
		if (M.abs(-viewDestY + y * mapCellSize) > viewMoveYAt) {
			viewDestY += mapCellSize * dy
		}
		moveUntil = now + moveDuration
		spawnDust(playerX, playerY)
	}
}

function processKey() {
	if (gameOver) {
		return
	}
	if (keysDown[37] || keysDown[72]) {
		move(-1, 0)
	}
	if (keysDown[39] || keysDown[76]) {
		move(1, 0)
	}
	if (keysDown[38] || keysDown[75]) {
		move(0, -1)
	}
	if (keysDown[40] || keysDown[74]) {
		move(0, 1)
	}
}

function pageXToGl(x) {
	return (x - halfWidth) / halfWidth
}

function pageYToGl(y) {
	return (halfHeight - y) / (halfHeight / yMax)
}

function setPointer(event, down) {
	if (!down) {
		pointersLength = event.touches ? event.touches.length : 0
	} else if (event.touches) {
		var touches = event.touches
		pointersLength = touches.length

		for (var i = pointersLength; i--;) {
			var t = touches[i]
			pointersX[i] = pageXToGl(t.pageX)
			pointersY[i] = pageYToGl(t.pageY)
		}
	} else {
		pointersLength = 1
		pointersX[0] = pageXToGl(event.pageX)
		pointersY[0] = pageYToGl(event.pageY)
	}
	event.preventDefault()
}

function pointerCancel(event) {
	setPointer(event, false)
}

function pointerUp(event) {
	setPointer(event, false)
}

function pointerMove(event) {
	setPointer(event, pointersLength)
}

function pointerDown(event) {
	setPointer(event, true)
}

function setKey(event, down) {
	keysDown[event.keyCode] = down
	event.stopPropagation()
}

function keyUp(event) {
	setKey(event, false)
}

function keyDown(event) {
	setKey(event, true)
	processKey()
}

function wireInputs() {
	D.onkeydown = keyDown
	D.onkeyup = keyUp

	D.onmousedown = pointerDown
	D.onmousemove = pointerMove
	D.onmouseup = pointerUp
	D.onmouseout = pointerCancel

	if ('ontouchstart' in D) {
		D.ontouchstart = pointerDown
		D.ontouchmove = pointerMove
		D.ontouchend = pointerUp
		D.ontouchleave = pointerCancel
		D.ontouchcancel = pointerCancel
	}
}

function resize() {
	var width = gl.canvas.clientWidth,
		height = gl.canvas.clientHeight

	halfWidth = width >> 1
	halfHeight = height >> 1
	yMax = height / width

	gl.canvas.width = width
	gl.canvas.height = height
	gl.viewport(0, 0, width, height)

	var ref = 16
	scaleFactor = M.min(1, yMax) * .1 / ref

	spriteSize = scaleFactor * ref
	mapCellSize = scaleFactor * 2 * ref
	maxColsInView = (2 / mapCellSize | 0) + 2
	maxRowsInView = ((yMax + yMax) / mapCellSize | 0) + 2

	var halfCellSize = mapCellSize * .5
	viewXMin = -1 + halfCellSize
	viewXMax = 1 - (mapCols * mapCellSize) + halfCellSize
	viewYMin = yMax - halfCellSize
	viewYMax = (mapRows * mapCellSize) - yMax - halfCellSize
	viewMoveXAt = .7
	viewMoveYAt = yMax * viewMoveXAt

	setViewDest(playerX, playerY)
	viewX = viewDestX
	viewY = viewDestY

	perspective = new FA([
		1, 0, 0,
		0, width / height, 0,
		0, 0, 1
	])

	transformation = new FA([
		1, 0, 0,
		0, 1, 0,
		0, 0, 1
	])
}

function createMap() {
	mapCols = mapRows = 31
	for (var i = mapCols * mapRows; i--;) {
		map[i] = SAND
		items[i] = -1
	}
	playerX = playerDestX = mapCols >> 1
	playerY = playerDestY = mapRows >> 1
}

function initDust() {
	for (var i = dustLength; i-- > 0;) {
		dust[i] = {
			x: 0,
			y: 0,
			life: 0
		}
	}
}

function getEnabledAttribLocation(program, name) {
	var loc = gl.getAttribLocation(program, name)
	gl.enableVertexAttribArray(loc)
	return loc
}

function calcUvCoords() {
	var pos = [
			SAND,
			PLAYER,
			DUST,
		],
		coords = [],
		xf = 1 / atlas.width,
		yf = 1 / atlas.height,
		nx = .5 * xf,
		ny = .5 * yf,
		grid = 16,
		perRow = atlas.width / grid,
		index = 0

	for (var i = 0, pl = pos.length; i < pl; ++i) {
		var p = pos[i],
			x = (p % perRow) * grid,
			y = M.floor(p / perRow) * grid,
			l = xf * x,
			t = yf * y,
			r = xf * (x + grid),
			b = yf * (y + grid)

		sprites[p] = index++

		/* TRIANGLE_STRIP order:
		 *   A--C   A: x, y
		 *   | /|   B: x, y
		 *   |/ |   C: x, y
		 *   B--D   D: x, y */
		coords.push(
			l + nx, t + ny,
			l + nx, b - ny,
			r - nx, t + ny,
			r - nx, b - ny,
		)
	}

	return coords
}

function initBuffers(program) {
	vertexBuffer = gl.createBuffer()
	gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)
	gl.bufferData(gl.ARRAY_BUFFER,
		new FA([
			-1, 1,
			-1, -1,
			1, 1,
			1, -1]),
		gl.STATIC_DRAW)

	uvBuffer = gl.createBuffer()
	gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer)
	gl.bufferData(gl.ARRAY_BUFFER, new FA(calcUvCoords()), gl.STATIC_DRAW)

	vertexBufferLoc = getEnabledAttribLocation(program, 'p')
	uvBufferLoc = getEnabledAttribLocation(program, 'uv')

	perspectiveLoc = gl.getUniformLocation(program, 'perspective')
	transformationLoc = gl.getUniformLocation(program, 'transformation')
	textureLoc = gl.getUniformLocation(program, 'texture')
}

function createTextureFrom(image) {
	var id = gl.createTexture()
	if (id < 1) {
		return
	}

	gl.bindTexture(gl.TEXTURE_2D, id)
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE,
		image)

	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)

	gl.generateMipmap(gl.TEXTURE_2D)

	return id
}

function compileShader(type, src) {
	var shader = gl.createShader(type)
	gl.shaderSource(shader, src)
	gl.compileShader(shader)
	return gl.getShaderParameter(shader, gl.COMPILE_STATUS) ? shader : null
}

function getContext() {
	var c = D.getElementById('Canvas')
	return c.getContext('webgl') || c.getContext('experimental-webgl')
}

function init() {
	gl = getContext()

	texture = createTextureFrom(atlas)

	program = gl.createProgram()
	gl.attachShader(program, compileShader(gl.VERTEX_SHADER,
		D.getElementById('VertexShader').textContent))
	gl.attachShader(program, compileShader(gl.FRAGMENT_SHADER,
		D.getElementById('FragmentShader').textContent))
	gl.linkProgram(program)
	gl.useProgram(program)

	initBuffers(program)

	gl.enable(gl.BLEND)
	gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)
	gl.clearColor(.066, .066, .066, 1)

	wireInputs()
	initDust()
	createMap()

	W.onresize = resize
	resize()

	run()
}

function load() {
	atlas = new Image()
	atlas.src = 'atlas.png'
	atlas.onload = init
}

W.onload = load
</script>
</body>
</html>
